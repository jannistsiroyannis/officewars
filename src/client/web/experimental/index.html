<html>
    <head>
        <meta charset="UTF-8">
        <title>OfficeWars</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"
            integrity="sha512-NLtnLBS9Q2w7GKK9rKxdtgL7rA7CAS85uC/0xd9im4J/yOL4F9ZVlv634NAM7run8hz3wI2GabaA6vv8vJtHiQ=="
            crossorigin="anonymous"
        ></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"
            crossorigin="anonymous"
        ></script>
        <script src="../lazy-client.js"></script>
        <script src="officewars.js"></script>
        <script src="api.js"></script>
<style>
body {
    padding: 0;
    margin: 0;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
}

* {
    box-sizing: border-box;
}

#play-button {
    border-radius: 50%;
    width: 50px;
    height: 50px;
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(0,0,0,0.6);
    z-index: 10;
    transition: background-color 0.2s;
    border: solid 5px rgba(255, 255, 255, 0.8);
}

#play-button:hover {
    background-color: rgba(255,255,255,0.6);
}

#play-button::after {
    content: "";
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0; 
    height: 0; 
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-left: 12px solid #fff;
    transform: translateX(-50%) translateY(-50%);
    transition: border-left 0.2s;
}

#play-button:hover::after {
    border-left: 12px solid #000;
}

#leader-board {
    position: absolute;
    top: 15px;
    left: 15px;
}

#leader-board > .entry {
    position: relative;
    display: block;
    width: 150px;
    color: #fff;
    padding: 10px;
    margin-bottom: 5px;
    background-color: rgba(0, 0, 0, 0.6);
    transition: background-color 0.2s, color 0.2s;
}
#leader-board > .entry:hover {
    color: #000;
    background-color: rgba(255, 255, 255, 0.6);
} 
#leader-board > .entry > .dot {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin-right: 10px;
    vertical-align: middle;
    border: solid 2px rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    background-color: #f00;
    transition: background-color 0.2s, border-color 0.2s;
}
#leader-board > .entry:hover > .dot {
    border-color: rgba(0, 0, 0, 0.6);
    background-color: #f00;
}
#leader-board > .entry > .points {
    display: block;
    position: absolute;
    top: 0;
    left: calc(100% + 5px);
    height: 100%;
    padding: 10px;
    color: #000;
    background-color: rgba(255, 255, 255, 0.6);
}
</style>
    </head>
    <body>
        <div id="app">
            <div id="leader-board">
            </div>
        </div>
    </body>
    <script>
function playMusic() {
    const music = document.getElementById("bg-music")
    music.play()
}
function showPlayers(game) {
    const lb = document.getElementById("leader-board")
    const playerPoints = game.players.map(player => [
        player,
        Array.from(
            game.states[game.states.length - 1].ownedBy.values()
        ).filter(v => v === player).length
    ]).sort(([a, ap], [b, bp]) => bp - ap)
    const content = playerPoints.map(([player, points]) => (
        `<div class="entry"><span class="dot" style="background-color:${player.color}"></span>${player.name}<span class="points">${points}</span></div>`
    )).join("\n")
    lb.innerHTML = content
}
async function start() {
    const queryString = window.location.search
    const urlParams = new URLSearchParams(queryString)
    const gameId = urlParams.get("game")
    const api = await ClientApi.fromModule(Module)
    const gi = await api.loadGame("/cgi-bin/server/state/" + gameId)
    const game = Game.fromGameInspector(gi)
    let camera, scene, renderer;
    let mesh;
    let controls;
    const connectionTextureSpeeds = [-0.01, 0.0025, -0.005]
    let connectionTextures = [];
    let planets = []

    init()
    animate()
    showPlayers(game)

    function init() {

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 )
        scene = new THREE.Scene()

        const center = game.nodes.map(n => n.position).reduce(
            (acc, p) => acc.map((v, i) => v + p[i])
        ).map(v => v / game.nodes.length)
        
        const textureLoader = new THREE.TextureLoader()
        const spaceTexture = textureLoader.load(
            "https://images.unsplash.com/photo-1505506874110-6a7a69069a08?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1024&q=80"
        );
        spaceTexture.wrapS = THREE.RepeatWrapping;
        spaceTexture.wrapT = THREE.RepeatWrapping;
        spaceTexture.repeat.set(2, 1)
        const spaceMaterial = new THREE.MeshBasicMaterial( { map: spaceTexture, side: THREE.BackSide } )
        const spaceGeometry = new THREE.SphereGeometry( 800, 20, 10 );
        const space = new THREE.Mesh(
            spaceGeometry,
            spaceMaterial
        );
        space.position.set(...center)
        scene.add( space );

        const planetTextures = [
            "https://images.unsplash.com/photo-1544611910-3cb8d15aa90e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1579706624295-3c81eaef2533?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1581553804801-e46ad9c6a60f?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1618260589896-e6f55a14e730?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1547556987-f3de424ebfbb?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1616649357435-aca0f077e487?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1553949345-eb786bb3f7ba?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1607594682446-2c4d5fc5644e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1617058074336-221c74dbb7c1?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1501166222995-ff31c7e93cef?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
            "https://images.unsplash.com/photo-1523447704114-37cea08ee064?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=512&q=80",
        ].map(url => textureLoader.load(url))
        const outlineMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide})
        outlineMaterial.color = new THREE.Color("#000000")
        for (const pt of planetTextures) {
            pt.wrapS = THREE.RepeatWrapping;
            pt.wrapT = THREE.RepeatWrapping;
            pt.repeat.set(2, 1)
        }
        const planetSizes = [
            0.5,
            0.4,
            0.3,
            0.55,
            0.45
        ]
        const outlineGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.025, 20, 10)
        ))
        const containerGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.175, 20, 10)
        ))
        const ownerGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.15, 20, 10)
        ))
        const planetGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r, 20, 10)
        ))
        const planetMaterials = planetTextures.map(tex => (
            new THREE.MeshBasicMaterial({ map: tex })
        ))
        const lastState = game.states[game.states.length - 1]
        planets = game.nodes.map((node, nodeId) => {
            const planet = new THREE.Group()
            const owner = lastState.ownedBy.get(node)
            const selectionMaterial = outlineMaterial.clone()
            if (owner) {
                const planetOutlineMaterial = outlineMaterial.clone()
                planetOutlineMaterial.color = new THREE.Color(owner.color)
                const ownerView = new THREE.Mesh(
                    ownerGeometries[nodeId % planetSizes.length],
                    planetOutlineMaterial
                )
                const container = new THREE.Mesh(
                    containerGeometries[nodeId % planetSizes.length],
                    selectionMaterial
                )
                container.gameNode = node
                planet.add(
                    container,
                    ownerView
                )
            }

            const selection = new THREE.Mesh(
                outlineGeometries[nodeId % planetSizes.length],
                selectionMaterial
            )
            selection.gameNode = node
            const core = new THREE.Mesh(
                planetGeometries[nodeId % planetSizes.length],
                planetMaterials[nodeId % planetMaterials.length]
            )
            planet.add(
                selection,
                core,
            )
            planet.position.set(...node.position.map(v => v))
            scene.add(planet)
            return {
                group: planet,
                selection: selection,
                core: core,
            }
        })

        
        connectionTextures = connectionTextureSpeeds.map(s => {
            const tex = textureLoader.load(
                "https://images.unsplash.com/photo-1612107660524-c163953f7e07?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=512&q=80"
            )
            tex.wrapS = THREE.RepeatWrapping
            tex.wrapT = THREE.RepeatWrapping
            return tex
        })
        const connectionMaterials = connectionTextures.map(tex => (
            new THREE.MeshBasicMaterial(
                {
                    map: tex,
                    blending: THREE.AdditiveBlending
                }
            )
        ))
        for (const nodeId in game.nodes) {
            const node = game.nodes[nodeId]
            const nodeVec = new THREE.Vector3(...node.position)
            for (const target of node.connections) {
                const targetVec = new THREE.Vector3(...target.position)
                const distance = nodeVec.distanceTo(targetVec)
                const size = planetSizes[nodeId % planetSizes.length]
                const variants = [1, 0.7, 0.35]
                for (const variantId in variants) {
                    const variant = variants[variantId]
                    const connectionGeometry = new THREE.ConeGeometry( 0.1 * size * Math.pow(2 - variant, 4), distance * 0.55 * variant, 10 )
                    connectionGeometry.applyMatrix4(
                        new THREE.Matrix4().makeTranslation(0, variant * distance * 0.275, 0)
                    );
                    const connection = new THREE.Mesh(
                        connectionGeometry,
                        connectionMaterials[variantId % connectionMaterials.length]
                    );
                    connection.position.set(...[
                        node.position[0],
                        node.position[1],
                        node.position[2]
                    ])
                    const vector = new THREE.Vector3().subVectors(targetVec, nodeVec)
                    const axis = new THREE.Vector3(0, 1, 0);
                    connection.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
                    scene.add( connection );
                }
            }
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } )
        renderer.setPixelRatio( window.devicePixelRatio )
        renderer.setSize( window.innerWidth, window.innerHeight )
        raycaster = new THREE.Raycaster();
        renderer.domElement.addEventListener( 'click', raycastFunc(selectHandler), false )
        document.body.appendChild( renderer.domElement )

        controls = new THREE.OrbitControls( camera, renderer.domElement )
        camera.position.set(0, 0, 10);
        console.log(center)
        controls.target.set(...center)
        controls.update();

        window.addEventListener( 'resize', onWindowResize );

    }

    function raycastFunc(handler = () => {}) {
        const raycaster = new THREE.Raycaster()
        raycast = function(e) {
            const mouse = {
                x: ( e.clientX / window.innerWidth ) * 2 - 1,
                y: -( e.clientY / window.innerHeight ) * 2 + 1,
            }
            raycaster.setFromCamera( mouse, camera )
            const intersects = raycaster.intersectObjects(
                scene.children.flatMap(c => [c, ...c.children])
            )

            handler(intersects)
        }
        return raycast
    }

    function selectHandler(intersects) {
        const [nodeObject, ...others] = intersects.filter(
            i => !!i.object.gameNode
        ).map(i => i.object)

        if (nodeObject) {
            planets.forEach(p => p.selection.material.color.setRGB(0, 0, 0))
            nodeObject.material.color.setRGB(1, 1, 1)
        }
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

        requestAnimationFrame( animate );
        for (const texId in connectionTextures) {
            const tex = connectionTextures[texId]
            const speed = connectionTextureSpeeds[texId]
            tex.offset.set(...[
                tex.offset.x + speed * 0.5,
                tex.offset.y - speed * 0.05
            ])
        }
        const speeds = [1, 0.5, 0.7, 0.2, 0.9]
        const vecs = [
            new THREE.Vector3(0, 1, 0.5).normalize(),
            new THREE.Vector3(1, 1, 0).normalize(),
            new THREE.Vector3(0.5, 0, 1).normalize()
        ]
        for (const planetId in planets) {
            const planet = planets[planetId]
            const quaternion = new THREE.Quaternion()
            quaternion.setFromAxisAngle(
                vecs[planetId % vecs.length],
                Math.PI * speeds[planetId % speeds.length] * 0.0025
            )
            planet.core.applyQuaternion(quaternion)
        }
        controls.update();

        renderer.render( scene, camera );

    }
}
start()
    </script>
</html>